# Master Devops - Docker, Kubernetes, Terraform and Azure Devops

## Learn Devops with Docker, Kubernetes, Terraform, Ansible, Jenkins and Azure Devops

## Pipeline Project Github Repositories
- Azure Devops - https://github.com/in28minutes/azure-devops-kubernetes-terraform-pipeline
- Jenkins - https://github.com/in28minutes/jenkin-devops-microservice

## Step By Step Details

### Docker and DevOps
- Step 01 - Docker and DevOps - Installation and Introduction
- Step 02 - Your First Docker Usecase
- Step 03 - Important Docker Concepts - Registry, Repository, Tag, Image and Container
- Step 04 - Playing with Docker Images - Java, JavaScript and Python
- Step 05 - Playing with Docker - Detached Mode and Logs
- Step 06 - Playing with Docker Images and Containers
- Step 07 - Understanding Docker Architecture - Docker Client, Docker Engine
- Step 08 - Understanding Docker Popularity - My 3 Top Reasons
- Step 09 - Learning Docker Images - Commands
- Step 10 - Learning Docker Containers - Commands
- Step 11 - Learning Docker Commands - system and stats
- Step 12 - Building Docker Images for Python Application
- Step 13 - Understanding creation of Docker Images in Depth
- Step 14 - Pushing Python App Docker Image to Docker Hub
- Step 15 - Building and Pushing Docker Image for Node JavaScript App
- Step 16 - Building and Pushing Docker Image for Java Application
- Step 17 - Building Efficient Docker Images - Improving Layer Caching
- Step 18 - Understanding ENTRYPOINT vs CMD
- Step 19 - Docker and Microservices - Quick Start
- Step 20 - Introduction to Microservices - CE and CC
- Step 21 - Running Microservices as Docker Containers
- Step 22 - Using Docker Link to Connect Microservices
- Step 23 - Using Custom Networking to Connect Microservices
- Step 24 - Using Docker Compose to Simplify Microservices Launch
- Step 25 - Understanding Docker Compose further

### Kubernetes and DevOps
- Step 01 - Getting Started with Docker, Kubernetes and Google Kubernetes Engine
- Step 02 - Creating Google Cloud Account
- Step 03 - Creating Kubernetes Cluster with Google Kubernete Engine (GKE)
- Step 04 - Review Kubernetes Cluster and Learn Few Fun Facts about Kubernetes
- Step 05 - Deploy Your First Spring Boot Application to Kubernetes Cluster
- Step 06 - Quick Look at Kubernetes Concepts - Pods, Replica Sets and Deployment
- Step 07 - Understanding Pods in Kubernetes
- Step 08 - Understanding ReplicaSets in Kubernetes
- Step 09 - Understanding Deployment in Kubernetes
- Step 10 - Quick Review of Kubernetes Concepts - Pods, Replica Sets and Deployment
- Step 11 - Understanding Services in Kubernetes
- Step 12 - Quick Review of GKE on Google Cloud Console 
- Step 13 - Understanding Kubernetes Architecture - Master Node and Nodes
- Step 14 - Understand Google Cloud Regions and Zones
- Step 15 - Installing GCloud
- Step 16 - Installing Kubectl 
- Step 17 - Understand Kubernetes Rollouts
- Step 18 - Generate Kubernetes YAML Configuration for Deployment and Service
- Step 19 - Understand and Improve Kubernetes YAML Configuration
- Step 20 - Using Kubernetes YAML Configuration to Create Resources
- Step 21 - Understanding Kubernetes YAML Configuration - Labels and Selectors
- Step 22 - Quick Fix to reduce release downtime with minReadySeconds
- Step 23 - Understanding Replica Sets in Depth - Using Kubernetes YAML Config
- Step 24 - Configure Multiple Kubernetes Deployments with One Service
- Step 25 - Playing with Kubernetes Commands - Top Node and Pod
- Step 26 - Delete Hello World Deployments
- Step 27 - Quick Introduction to Microservices - CE and CC
- Step 28 - Deploy Microservices to Kubernetes
- Step 29 - Understand Environment Variables created by Kubernetes for Services
- Step 30 - Microservices and Kubernetes Service Discovery - Part 1
- Step 31 - Microservices and Kubernetes Service Discovery - Part 2 DNS
- Step 32 - Microservices Centralized Configuration with Kubernetes ConfigMaps
- Step 33 - Simplify Microservices with Kubernetes Ingress - Part 1
- Step 34 - Simplify Microservices with Kubernetes Ingress - Part 2
- Step 35 - Delete Kubernetes Clusters

### Terraform
- Step 01 - Creating and Initializing First Terraform Project
- Step 02 - Create AWS IAM User Access Key and Secret
- Step 03 - Configure Terraform Environment Variables for AWS Access Keys
- Step 04 - Creating AWS S3 Buckets with Terraform
- Step 05 - Playing with Terraform State - Desired, Known and Actual
- Step 06 - Playing with Terraform Console
- Step 07 - Creating AWS IAM User with Terraform
- Step 08 - Updating AWS IAM User Name with Terraform
- Step 09 - Understanding Terraform tfstate files in depth
- Step 10 - gitignore Terraform tfstate files
- Step 11 - Refactoring Terraform files - Variables, Main and Outputs
- Step 12 - Creating Terraform Project for Multiple IAM Users
- Step 13 - Playing with Terraform Commands - fmt, show and console
- Step 14 - Recovering from Errors with Terraform
- Step 15 - Understanding Variables in Terraform
- Step 16 - Creating Terraform Project for Understanding List and Map
- Step 17 - Adding Elements - Problem with Terraform Lists
- Step 18 - Creating Terraform Project for Learning Terraform Maps 
- Step 19 - Quick Review of Terraform FAQ
- Step 20 - Understanding Creation of EC2 Instances in AWS Console
- Step 21 - Creating New Terraform Project for AWS EC2 Instances
- Step 22 - Creating New EC2 Key Pair and Setting Up
- Step 23 - Adding AWS EC2 Configuration to Terraform Configuration
- Step 24 - Installing Http Server on EC2 with Terraform - Part 1
- Step 25 - Installing Http Server on EC2 with Terraform - Part 2
- Step 26 - Remove hardcoding of Default VPC with AWS Default VPC
- Step 27 - Remove hardcoding of subnets with Data Providers
- Step 28 - Remove hardcoding of AMI with Data Providers
- Step 29 - Playing with Terraform Graph and Destroy EC2 Instances
- Step 30 - Creating New Terraform Project for AWS EC2 with Load Balancers
- Step 31 - Create Security Group and Classic Load Balancer in Terraform
- Step 32 - Review and Destroy AWS EC2 with Load Balancers
- Step 33 - Creating Terraform Project for Storing Remote State in S3 
- Step 34 - Create Remote Backend Project for Creating S3 Buckets
- Step 35 - Update User Project to use AWS S3 Remote Backend
- Step 36 - Creating multiple environments using Terraform Workspaces
- Step 37 - Creating multiple environments using Terraform Modules

### Ansible
- Step 01 - Creating EC2 Instances for Ansible - Manually and with Terraform
- Step 02 - Setting Ansible Project with cfg and ansible hosts
- Step 03 - Playing with Ansible Commands
- Step 04 - Playing with Ansible Host File and Custom Groups
- Step 05 - Creating an Ansible Playbook for Ping
- Step 06 - Understanding Ansible Terminology - Control Node, Managed Nodes, Inventory
- Step 07 - Creating New Ansible Playbook for Executing Shell Commands
- Step 08 - Playing with Ansible Variables
- Step 09 - Creating New Ansible Playbook for Understanding Ansible Facts
- Step 10 - Creating New Ansible Playbook for Installing Apache and Serving HTML
- Step 11 - Reuse and Executing Multiple Ansible Playbooks
- Step 12 - Understanding Conditionals and Loops with Ansible
- Step 13 - Configuring EC2 Dynamic Inventory with Ansible
- Step 14 - Creating AWS EC2 Instances with Ansible
- Step 15 - Providing Declarative Configuration with Ansible
- Step 16 - Deleting all AWS EC2 Instances

### Azure DevOps - Pipelines
- Step 01 - Getting Started with Azure DevOps - First Project
- Step 02 - Setting up Git Repo for Azure DevOps Pipeline
- Step 03 - Creating your first Azure DevOps Pipeline
- Step 04 - Getting Started with Azure DevOps - Agents and Jobs - 1
- Step 05 - Getting Started with Azure DevOps - Agents and Jobs - 2
- Step 06 - Using dependsOn with Jobs
- Step 07 - Creating Azure DevOps Pipeline for Playing with Stages 
- Step 08 - Playing with Variables and dependsOn for Stages
- Step 09 - Understanding Azure DevOps Pipeline Variables
- Step 10 - Creating Azure DevOps Tasks for Copy Files and Publish Artifacts
- Step 11 - Running Azure DevOps Jobs on Multiple Agents
- Step 12 - Understanding Azure DevOps Deployment Jobs - Environments and Approvals
- Step 13 - Build and Push Docker Image in Azure DevOps - Part 1
- Step 14 - Build and Push Docker Image in Azure DevOps - Part 2
- Step 15 - Playing with Azure DevOps Releases
- Step 01 - Review Terraform Configuration for Azure Kubernetes Cluster Creation
- Step 02 - Setting up Client ID, Secret and Public Key for Azure Kubernetes Cluster Creation
- Step 03 - Creating Azure DevOps Pipeline for Azure Kubernetes Cluster IAAC 
- Step 04 - Performing Terraform apply to create Azure Kubernetes Cluster in Azure DevOps
- Step 05 - Connecting to Azure Kubernetes Cluster using Azure CLI
- Step 06 - Creating Azure DevOps Pipeline for Deploying Microservice to Azure Kubernetes
- Step 07 - Creating V2 and Enable Build and Push of Docker Image - Part 1
- Step 08 - Creating V2 and Enable Build and Push of Docker Image - Part 2
- Step 09 - Performing Terraform destroy to delete Azure Kubernetes Cluster in Azure DevOps
- Step 10 - Quick Review of Terraform destroy

### CI, CD, IAAC with Kubernetes on AWS with Azure DevOps - Pipelines
- Step 01 - Review Terraform Configuration for AWS EKS Cluster Creation
- Step 02 - Setup AWS S3 Buckets and Subnet Configuration
- Step 03 - Enable AWS Tools in Azure DevOps and Create Azure DevOps Pipeline
- Step 04 - Performing Terraform apply to create AWS EKS Cluster in Azure DevOps
- Step 05 - Retry Terraform apply for Creating Cluster Binding
- Step 06 - Configure AWS CLI and Setup Kubernetes Connection using Service Account
- Step 07 - Creating Azure DevOps Pipeline for Deploying Microservice to AWS EKS
- Step 08 - Creating V3 and Enable Build and Push of Docker Image - Part 1
- Step 09 - Creating V3 and Enable Build and Push of Docker Image - Part 2
- Step 10 - Performing Terraform destroy to delete AWS EKS Cluster in Azure DevOps - 1
- Step 11 - Performing Terraform destroy to delete AWS EKS Cluster in Azure DevOps - 2

### CI, CD, IAAC with Kubernetes on Azure with Azure DevOps - Pipelines
- Step 01 - Getting Started with Azure DevOps with Demo Generator
- Step 02 - Overview of Azure DevOps - Boards, Wiki, Repos and Pipelines
- Step 03 - Exploring Azure DevOps Boards - Epics, Features and User Stories
- Step 04 - Azure DevOps - Boards View vs Backlogs View
- Step 05 - Understanding Sprints in Azure DevOps
- Step 06 - Creating Azure DevOps Queries
- Step 07 - Playing with Azure DevOps Repos
- Step 08 - Quick Review of Azure DevOps Pipelines
- Step 09 - Quick Review of Azure DevOps

### CI/CD with Jenkins
- Step 01 - Introduction and Launching Jenkins as Docker Container
- Step 02 - Initializing Jenkins Plugins and Creating Github Repo
- Step 03 - Setting up Docker and Maven in Jenkins and First Pipeline Run
- Step 04 - Understanding Scripted Pipelines in Jenkins
- Step 05 - Understanding Declarative Pipelines in Jenkins - Stages
- Step 06 - Using Docker Images as Jenkins Pipeline Agents
- Step 07 - Review Pipeline Syntax and Understanding Variables
- Step 08 - Configuring Jenkins Pipeline Path with Docker and Maven Tools
- Step 09 - Running Unit Tests and Integration Tests in Jenkins Pipelines - 1
- Step 10 - Running Unit Tests and Integration Tests in Jenkins Pipelines - 2
- Step 11 - Build and Push Docker Image in Jenkins Pipelines - 1
- Step 12 - Build and Push Docker Image in Jenkins Pipelines - 2

## Next Steps

## Diagrams

```

graph architecture {

node[style=filled,color="#59C8DE"]
//node [style=filled,color="#D14D28", fontcolor=white];
rankdir = LR
node[shape=record, width=1.6]


ParentNode1 -- ChildNode1
ChildNode1 -- ChildNode2
ChildNode1 -- ChildNode3
ChildNode1 -- ChildNode4

ParentNode1[label=<Configuration <BR/>and Scripts>]
ChildNode1[label=<Ansible>];
ChildNode2[label=<Server 1>];
ChildNode3[label=<Server 2>];
ChildNode4[label=<Server 3>];

}

graph architecture {
layout="circo";
node[style=filled,  fillcolor="#D14D28", fontcolor=white]
//node [style=filled,color="#D14D28", fontcolor=white];
rankdir = LR
node[shape = circle,  width=1]
edge [dir=forward]

Node1 -- Node2
Node2 -- Node3
Node3 -- Node4
Node4 -- Node1
//Node4 -- Node5
//Node5 -- Node6

Node1[label=<DEV>]
Node2[label=<QA>]
Node3[label=<STAGE>]
Node4[label=<PROD>]
//Node5[label=<5>]
//Node6[label=<6>]

}


graph architecture {
rankdir = LR
node[shape = circle,  width=1, style=filled,fillcolor="#59C8DE"]
//shape = record
edge [dir=forward]

Node1 -- Node2
Node2 -- Node3
Node3 -- Node4
//Node4 -- Node1
//Node4 -- Node5
//Node5 -- Node6

Node1[label=<DEV>]
Node2[label=<QA>]
Node3[label=<STAGE>]
Node4[label=<PROD>]
//Node5[label=<5>]
//Node6[label=<6>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1, style=filled,fillcolor="#59C8DE"]
//shape = record
edge [dir=forward]

Node3 -- Node4
Node4 -- Node5
Node5 -- Node6
Node6 -- Node7
Node7 -- Node1
Node1 -- Node2
Node2 -- Node3

Node1[label=<Code>]
Node2[label=<Build>]
Node3[label=<Test>]
Node4[label=<Release>]
Node5[label=<Deploy>]
Node6[label=<Review>]
Node7[label=<Plan>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1.3, style=filled,color="#59C8DE", fontcolor=black]
//shape = record
//fillcolor="#59C8DE"
//edge [dir=forward]
edge [width=0]
#D14D28

Node3 -- Node4[style=invis]
Node4 -- Node5[style=invis]
Node1 -- Node2[style=invis]
Node2 -- Node3[style=invis]

Node1[label=<Business>]
Node2[label=<Architecture>]
Node3[label=<Development>]
Node4[label=<Testing>]
Node5[label=<Operations>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1, style=filled,color="#D14D28", fontcolor=white]
//shape = record
//fillcolor="#59C8DE"
edge [dir=forward]

Node3 -- Node4
Node4 -- Node5
Node5 -- Node6
Node1 -- Node2
Node2 -- Node3

Node1[label=<Vision>]
Node2[label=<Iteration 1>]
Node3[label=<Iteration 2>]
Node4[label=<...>]
Node5[label=<Iteration n>]
Node6[label=<Product>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1, style=filled,fillcolor="#59C8DE"]
//shape = record
edge [dir=forward]

Node3 -- Node4
Node4 -- Node5
Node5 -- Node6
Node6 -- Node7
Node7 -- Node8
Node8 -- Node1
Node1 -- Node2
Node2 -- Node3

Node1[label=<Code>]
Node2[label=<Build>]
Node3[label=<Test>]
Node4[label=<Release>]
Node5[label=<Deploy>]
Node6[label=<Operate>]
Node7[label=<Monitor>]
Node8[label=<Plan>, fillcolor=white]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=2, style=filled,fillcolor="#D14D28", fontcolor=white]
//shape = record
//edge [dir=forward]

Node3 -- Node4
Node4 -- Node5
Node5 -- Node6
Node6 -- Node7
Node7 -- Node8
Node8 -- Node1
Node1 -- Node2
Node2 -- Node3

Node1[label=<<FONT POINT-SIZE="20">Continuous<br/>Planning</FONT>>]
Node2[label=<<FONT POINT-SIZE="20">Continuous<br/>Development</FONT>>]
Node3[label=<<FONT POINT-SIZE="20">Continuous<br/>Integration</FONT>>]
Node4[label=<<FONT POINT-SIZE="20">Continuous<br/>Deployment</FONT>>]
Node5[label=<<FONT POINT-SIZE="20">Continuous<br/>Testing</FONT>>]
Node6[label=<<FONT POINT-SIZE="20">Continuous<br/>Delivery</FONT>>]
Node7[label=<<FONT POINT-SIZE="20">Continuous<br/>Monitoring</FONT>>]
Node8[label=<<FONT POINT-SIZE="20">Continuous<br/>Feedback</FONT>>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1.6, style=filled,fillcolor="#D14D28", fontcolor=white]
//shape = record
edge [dir=forward]
{ rank=same Node1 Node2 Node3 }
{ rank=same Node7 Node8 Node9 }

Node3 -- Node4
Node4 -- Node5
Node5 -- Node6
Node6 -- Node7
Node7 -- Node8
Node8 -- Node9
Node1 -- Node2
Node2 -- Node3

Node1[label=<<FONT POINT-SIZE="20">Code<br/>Commit</FONT>>]
Node2[label=<<FONT POINT-SIZE="20">Unit<br/>Tests</FONT>>]
Node3[label=<<FONT POINT-SIZE="20">Integration<br/>Tests</FONT>>]
Node4[label=<<FONT POINT-SIZE="20">Package<br/></FONT>>]
Node5[label=<<FONT POINT-SIZE="20">Deploy</FONT>>]
Node6[label=<<FONT POINT-SIZE="20">Automated<br/> Tests</FONT>>]
Node7[label=<<FONT POINT-SIZE="20">Testing<br/>Approval</FONT>>, fillcolor=white, fontcolor=black]
Node8[label=<<FONT POINT-SIZE="20">Deploy<br/>NEXT</FONT>>]
Node9[label=<<FONT POINT-SIZE="20">..</FONT>>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1.6, style=filled,fillcolor="#D14D28", fontcolor=white]
//shape = record
edge [dir=forward]

Node3 -- Node4
Node4 -- Node5
Node1 -- Node2
Node2 -- Node3

Node1[label=<<FONT POINT-SIZE="20">Provision<br/>Server</FONT>>]
Node2[label=<<FONT POINT-SIZE="20">Install<br/>Java</FONT>>]
Node3[label=<<FONT POINT-SIZE="20">Install<br/>Tomcat</FONT>>]
Node4[label=<<FONT POINT-SIZE="20">Configure<br/>Tomcat</FONT>>]
Node5[label=<<FONT POINT-SIZE="20">Deploy<br/>Application</FONT>>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1.6, style=filled,fillcolor="#D14D28", fontcolor=white]
//shape = record
edge [dir=forward]

Node3 -- Node4
Node4 -- Node5
Node1 -- Node2
Node2 -- Node3

Node1[label=<<FONT POINT-SIZE="20">Create<br/>Template</FONT>>]
Node2[label=<<FONT POINT-SIZE="20">Provision<br/>Server</FONT>>]
Node3[label=<<FONT POINT-SIZE="20">Install<br/>Software</FONT>>]
Node4[label=<<FONT POINT-SIZE="20">Configure<br/>Software</FONT>>]
Node5[label=<<FONT POINT-SIZE="20">Deploy<br/>App</FONT>>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1.6, style=filled,fillcolor="#D14D28", fontcolor=white]
//shape = record
edge [dir=forward]

Node3 -- Node4
Node1 -- Node2
Node2 -- Node3

Node1[label=<<FONT POINT-SIZE="20">Provision<br/>Server v1</FONT>>]
Node2[label=<<FONT POINT-SIZE="20">Provision<br/>Server v2</FONT>>]
Node3[label=<<FONT POINT-SIZE="20">Remove<br/>Server v1</FONT>>]
Node4[label=<<FONT POINT-SIZE="20">..<br/></FONT>>]

}
```

## Todo
- Course Promotion
  - 2 Emails on Udemy
  - 2 Emails to Email List
  - Create YouTube Course Preview Video
    - Add YouTube Course Preview Video as End Video for all videos
    - Make it the YouTube Default Video
  - Release atleast 20 small videos - one a day on Youtube
  - Do atleast 3 Youtube live sessions
  - After a Month
    - UFB
- Course Upload
  - Lecture with Github Repository Link
  - Lectures with All Commands for each section
  - Make two github repos public
  - Docker Text Instructions for Windows
  - Disable AWS/Azure Access Keys
- Videos
  - Costs
  - Todo from Appendix Course Section Titles
    - Azure CLI
    - AWS CLI
    - Exploring Java Microservices Projects
    - Importing Projects from Github into Visual Studio Code
  - DevOps
    - Introduction
    - Maturity Model
  - Introduction and Prerequisites
    - Terraform - IAAC Intro, Installation of Terraform, AWS Account, AWS Keys(We will create it in first section), IDE, VS Code Extensions.
    - Ansible - Intro to IAAC and Server Provisioning vs Server Configuration Management, Installation, AWS Account, IDE, Python, PIP, !Windows, 
    - Azure DevOps - Azure Account, Docker Basics, CI, CD, IDE
    - Azure K8S Automation - Kubernetes, Terraform (Remote Backend), IAAC, Azure DevOps, Azure, Azure CLI, FREE TIER??
    - AWS K8S Automation - Kubernetes, Terraform, Azure DevOps, AWS, AWS CLI, Costs - EKS is NOT FREE
    - Jenkins - IDE, Docker & Docker Compose
  - Miscellaneous
    - Docker
      - Importing Docker Projects into Visual Studio Code
    - Ansible 
      - Ansible on Windows OS
      - Setup Needed for Dynamic Inventory - readme.md
    - Terraform
      - Advantages of immutability
    - Azure DevOps
      - Consequences of Setting up One Github Repository - Pipelines. A discussion on Best Practices
    - Jenkins
      - Deploying Jenkins on Kubernetes
      - Any other exercises?
    - Course Intro's and Ending!
    - DevOps Periodic Table DT27 - Xebia
    - DevOps Assessment DT128 - Ravi's Video
    - Ravi's Presentation
- Appendix Course Section Titles
  - Installing Visual Studio Code 
    - Installing DONE
    - Installing Extensions
    - A few quick shortcuts
    - Importing Projects from Github into Visual Studio Code
  - Getting Started with AWS
    - AWS Account DONE
    - Installation of AWS CLI
  - Getting Started with Azure
    - Azure Account DONE
    - Installation of Azure CLI
  - Introduction to Microservices
    - Intro, Advantages, DONE
    - Exploring Java Microservices Projects